#!/usr/bin/python
#-------------------------------------------------------------------------------
# Copyright (c) 2015 manxinator
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#-------------------------------------------------------------------------------
# launchTest
# Author:   manxinator
# Created:  Wed Oct  7 02:28:49 PDT 2015
# Language: Python 2.7.6
#-------------------------------------------------------------------------------

import os, sys, argparse, getopt
import signal, subprocess, time
import atexit
import collections
from datetime import datetime
from os.path import basename

g_proc      = None
g_tcPars    = None
g_defPars   = None
g_launchScr = 'uLaunch.py'

g_maxThreads = 8
g_sleepDelay = 5

#-------------------------------------------------------------------------------
class launcher:
  """ Launcher class is a top level regressable script """

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class testClass:
    """ Class that abstracts one test """
    def __init__(self,**kwargs):
      self.bin        = None
      self.testName   = None
      self.testFile   = None
      self.numRuns    = None
      self.runDir     = None
      self.forceSeed  = None
      self.randScript = None
      self.preRun     = None
      self.postRun    = None
      self.exArgs     = None
      if kwargs is not None:
        if 'bin'        in kwargs: self.bin        = kwargs['bin'       ]
        if 'testName'   in kwargs: self.testName   = kwargs['testName'  ]
        if 'testFile'   in kwargs: self.testFile   = kwargs['testFile'  ]
        if 'numRuns'    in kwargs: self.numRuns    = kwargs['numRuns'   ]
        if 'runDir'     in kwargs: self.runDir     = kwargs['runDir'    ]
        if 'forceSeed'  in kwargs: self.forceSeed  = kwargs['forceSeed' ]
        if 'randScript' in kwargs: self.randScript = kwargs['randScript']
        if 'preRun'     in kwargs: self.preRun     = kwargs['preRun'    ]
        if 'postRun'    in kwargs: self.postRun    = kwargs['postRun'   ]
        if 'exArgs'     in kwargs: self.exArgs     = kwargs['exArgs'    ]
      self.groupList    = []
      self.actualRunDir = None

    def getCmdArray(self,originClass):
      """ Returns the command to invoke the test
          - calls to `which` consolidated in parent class
      """
      binPath  = originClass.binFullPaths[self.bin]
      retArray = [binPath]
      if self.randScript is not None: retArray = retArray + ["--randScript=" + self.randScript]
      if self.forceSeed  is not None: retArray = retArray + ["--forceSeed=%d" % self.forceSeed]
      if self.preRun     is not None: retArray = retArray + ["--preRun=%s"    % self.preRun]
      if self.postRun    is not None: retArray = retArray + ["--postRun=%s"   % self.postRun]
      if self.testFile   is not None: retArray = retArray + ["--testFile="  + self.testFile]
      if self.exArgs     is not None: retArray = retArray + ["--extraArgs=" + self.exArgs]
      return retArray

    def parseArray(self,args,prefix=None):
      """ Use argparse.ArgumentParser() on args array """
      global g_tcPars
      l_args = g_tcPars.parse_args(args)

      self.numRuns    = l_args.numRuns
      self.forceSeed  = l_args.forceSeed
      if l_args.bin        is not None: self.bin        = l_args.bin[0]
      if l_args.testName   is not None: self.testName   = l_args.testName[0]
      if l_args.testFile   is not None: self.testFile   = l_args.testFile[0]
      if l_args.runDir     is not None: self.runDir     = l_args.runDir[0]
      if l_args.randScript is not None: self.randScript = l_args.randScript[0]
      if l_args.preRun     is not None: self.preRun     = l_args.preRun[0]
      if l_args.postRun    is not None: self.postRun    = l_args.postRun[0]
      if l_args.extraArgs  is not None: self.exArgs     = l_args.extraArgs[0]

      # Some values may need to be corrected
      #
      if prefix is not None:
        if self.runDir is None:
          self.runDir = prefix
        else:
          self.runDir = prefix + '/' + self.runDir
      else:
        if self.runDir is None: self.runDir = '.'

      if self.numRuns  is None:           self.numRuns = 1
      elif isinstance(self.numRuns,list): self.numRuns = self.numRuns[0]

      if self.testName is None:
        if self.testFile is not None:
          dotPos = self.testFile.find('.')
          self.testName = self.testFile[:dotPos]

      doPrint = False
      if doPrint:
        self.printMembers()
        print ''

    def pullIntrospect(self,defArgs,ovrWr=False):
      """ Pull values from objects into self -- do not overwrite unless specified """
      methodList = [method for method in dir(defArgs) if (not callable(getattr(defArgs,method))) and (method[0] != '_')]
      for oneProp in methodList:
        if defArgs.__dict__[oneProp] is not None:
          if oneProp in self.__dict__.keys():
            if (self.__dict__[oneProp] is None) or ovrWr:
              self.__dict__[oneProp] = defArgs.__dict__[oneProp]

    def addGrpStr(self,grpStr):
      """ Adds a comma-separated string to list of groups """
      if (grpStr is not None) and (len(grpStr) > 0):
        self.groupList.extend(grpStr.split(','))

    def printMembers(self,outFh=sys.stdout):
      """ Debug function to introspect class and print variables """
      methodList = [method for method in dir(self) if (not callable(getattr(self,method))) and (method[0] != '_')]
      strLen     = len(max(methodList,key=len))
      fmtStr     = '{:' + str(strLen) + '}'
      outFh.write( "********** [testClass::printMembers]\n" )
      for oneStr in methodList:
        outFh.write( "* %s = %s\n" %(fmtStr.format(oneStr),str(self.__dict__[oneStr])) )
      outFh.write( "******************************\n" )

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class tlClass:
    """ Class that abstracts a single *.TL file """
    def __init__(self,**kwargs):
      self.tlName    = None       # Instance name of TL file
      self.tstObjLst = []         # List of Test Objects
      self.dirPref   = None       # Directory prefix

      self.dirPath  = None
      self.fileName = None
      self.verbose  = None
      self.parent   = None
      if kwargs is not None:
        if 'dirPath'  in kwargs: self.dirPath  = kwargs['dirPath']
        if 'fileName' in kwargs: self.fileName = kwargs['fileName']
        if 'verb'     in kwargs: self.verbose  = kwargs['verb']
        if 'origin'   in kwargs: self.parent   = kwargs['origin']

      if (self.dirPath is not None) and (self.fileName is not None):
        self.loadFile()
      elif self.fileName is not None:
        self.setTlName()

    def setTlName(self):
      """ Set the instance name from fileName """
      dotPos = self.fileName.rfind('.')
      self.tlName = self.fileName[:dotPos]

    def loadFile(self):
      """ Load and parse the *.TL file """
      # Fix fileName and dirPath
      self.fileName = self.fileName.lstrip('./')
      self.dirPath  = self.dirPath.rstrip('/')
      slPos         = self.fileName.rfind('/')
      if slPos >= 0:
        self.dirPath  = self.dirPath + '/' + self.fileName[:slPos]
        self.fileName = self.fileName[slPos+1:]
      self.setTlName()

      self.dirPref = self.dirPath[len(self.parent.e_cwd)+1:]
      if len(self.dirPref) == 0:
        self.dirPref = None
        tlFN         = self.fileName
        prnPref      = 'No Prefix'
      else:
        tlFN    = self.dirPath + '/' + self.fileName
        prnPref = '%s' % self.dirPref
      print "  + Loading: %s in %s [%s]" % (self.fileName,self.dirPath,prnPref)
      try:
        tlFH = open(tlFN,'r')
      except IOError:
        sys.stderr.write("ERROR: Failed to open %s for reading" %tlFN)
        sys.exit(108)
      else:
        lineNum = 0
        with tlFH:
          for oneLine in tlFH:
            lineNum    = lineNum +1
            groupNames = None

            # Remove comments from line
            remPos  = oneLine.find('#')
            oneLine = oneLine[:remPos].strip() if remPos >= 0 else oneLine.strip()

            # Support for `group
            grpPos  = oneLine.find('`group')
            if grpPos >= 0:
              grpStr = oneLine[grpPos:]
              lBr    = grpStr.find('(')
              rBr    = grpStr.find(')')
              if (lBr<0) or (rBr<0):
                slPos = tlFN.rfind('/')
                prFn  = tlFN[slPos+1:] if slPos >= 0 else tlFN
                sys.stderr.write("ERROR: Improperly formed `group statement in %s line %d" %(prFn,lineNum))
                sys.exit(109)

              oneLine    = oneLine[:grpPos] + grpStr[rBr+1:]
              groupNames = grpStr[lBr+1:rBr].strip()

            if len(oneLine) < 1:
              continue

            # Split into an array
            tmpSpl    = oneLine.split(' ')
            parseArgs = [myArg for myArg in tmpSpl if myArg != '']

            oneTest = self.parent.testClass()
            oneTest.parseArray(parseArgs,prefix=self.dirPref)
            oneTest.addGrpStr(groupNames)
            self.tstObjLst.append( oneTest )

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class tlDefault:
    """ Class that abstracts Default Test Lists """
    def __init__(self,**kwargs):
      self.dirPath  = None
      self.fileName = None
      self.verbose  = None
      self.parent   = None
      if kwargs is not None:
        if 'dirPath'  in kwargs: self.dirPath  = kwargs['dirPath']
        if 'fileName' in kwargs: self.fileName = kwargs['fileName']
        if 'verb'     in kwargs: self.verbose  = kwargs['verb']
        if 'origin'   in kwargs: self.parent   = kwargs['origin']

      # Create default class
      self.defTestValues = self.parent.testClass()

      # Force none on arguments with default values
      #
      self.defTestValues.numRuns = None
      self.defTestValues.runDir  = None

      if (self.dirPath is not None) and (self.fileName is not None):
        self.loadFile()

    def loadFile(self):
      """ Load and parse the default.TL file """
      # Load the default.TL file
      print "  + Loading: %s" % self.fileName
      try:
        tlFH = open(self.fileName,'r')
      except IOError:
        sys.stderr.write("ERROR: Failed to open %s for reading" %self.fileName)
        sys.exit(108)
      else:
        lineNum = 0
        with tlFH:
          for oneLine in tlFH:
            lineNum = lineNum +1

            # Remove comments from line
            remPos  = oneLine.find('#')
            oneLine = oneLine[:remPos].strip() if remPos >= 0 else oneLine.strip()

            if len(oneLine) < 1:
              continue

            # Split into an array and parse
            tmpSpl    = oneLine.split(' ')
            parseArgs = [myArg for myArg in tmpSpl if myArg != '']

            global g_defPars
            l_args = g_defPars.parse_args(parseArgs)

            # Add values to self.defTestValues
            self.defTestValues.pullIntrospect(l_args,True)

      doPrint = False
      if doPrint:
        #self.printMembers()
        self.printDefaults()
        print ''

    def printDefaults(self,outFh=sys.stdout):
      """ Debug function to introspect self.defTestValues values """
      methodList = [method for method in dir(self.defTestValues) if (not callable(getattr(self.defTestValues,method))) and (method[0] != '_')]
      strLen     = len(max(methodList,key=len))
      fmtStr     = '{:' + str(strLen) + '}'
      outFh.write( "++++++++++ [default values!]\n" )
      for oneStr in methodList:
        outFh.write( "+ %s = %s\n" %(fmtStr.format(oneStr),str(self.defTestValues.__dict__[oneStr])) )
      outFh.write( "++++++++++++++++++++++++++++++\n" )

    def printMembers(self,outFh=sys.stdout):
      """ Debug function to introspect tlDefault (self) and print variables """
      methodList = [method for method in dir(self) if (not callable(getattr(self,method))) and (method[0] != '_')]
      strLen     = len(max(methodList,key=len))
      fmtStr     = '{:' + str(strLen) + '}'
      outFh.write( "++++++++++ [default.tl members]\n" )
      for oneStr in methodList:
        outFh.write( "+ %s = %s\n" %(fmtStr.format(oneStr),str(self.__dict__[oneStr])) )
      outFh.write( "++++++++++++++++++++++++++++++\n" )

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class runTracker:
    """ Tracks one running test """
    def __init__(self,**kwargs):
      self.testObj = None
      self.runStr  = None
      self.idx     = None
      self.state   = 'Pending'
      self.proc    = None
      self.result  = 'NOT_CHECKED'
      if kwargs is not None:
        if 'testObj' in kwargs: self.testObj = kwargs['testObj']
        if 'runStr'  in kwargs: self.runStr  = kwargs['runStr']
        if 'idx'     in kwargs: self.idx     = kwargs['idx']

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

  def __init__(self):
    """ Initialization for launcher class """
    self.progName = None

    self.opt_verbose     = True       # TODO: reconsider this
    self.opt_bin         = None
    self.opt_testFile    = None       # currently, only used in self.inferTestLabel()
    self.opt_numRuns     = 1
    self.opt_runDir      = '.'
    self.opt_forceSeed   = None
    self.opt_randScript  = None
    self.opt_preRun      = None
    self.opt_postRun     = None
    self.opt_testSuff    = ".aok"
    self.opt_exArgs      = None
    self.testLabel       = None

    self.e_cwd = os.getcwd().rstrip('/')      # os.environ.get('PWD')
    self.e_lwd = os.environ['LOCAL_WS_DIR'].rstrip('/')

    self.testLabelInferred = False
    self.runLogName        = "run.log"   # Perhaps make this programmable

    self.cfg_testList     = []    # List of *.tl files
    self.cfg_defList      = []

    self.collectId_name   = []                              # Test ID collection for Test Names
    self.collectId_group  = collections.defaultdict(list)   # Test ID collection for Groups
    self.duplicateTlFn    = dict()                          # TL filenames with duplicates
    self.binFullPaths     = dict()                          # Binary to full paths

    self.runResultFile    = 'result.launchtest.temp'        # Hardcoded in several places

  def setProgName(self,a_progName):
    """ Sets program name for printing -- may be cleaned up: basename, etc. """
    self.progName = a_progName

  def printHelp(self,exitCode):
    """ Prints the help instructions and exits. """
    # Usage options split into two categories
    #
    print("Usage: %s [OPTIONS] TEST_LABEL" % basename(self.progName))
    print("--------------------------------------------------")
    print(" Options for both Standalone and Regression:")
    print("  -b <STR>, --bin=<STR>         Executable binary")
    print("  -F <NUM>, --forceSeed=<NUM>   Run test with given random seed")
    print("  -r <STR>, --randScript=<STR>  Specify random seed generator script")
    print("  -P <STR>, --preRun=<STR>      Comma-separated list of pre-run scripts")
    print("  -p <STR>, --postRun=<STR>     Comma-separated list of post-run scripts")
    print("  -z <STR>, --testSuffix=<STR>  Specify test suffix; defaults to '.aok'")
    print("  -x <STR>, --extraArgs=<STR>   Additional arguments")
    print("--------------------------------------------------")
    print(" Standalone Options:")
    print("  -t <STR>, --testFile=<STR>    Specify test file")
    print("                                - only used when TEST_LABEL not defined")
    print("                                - standalone test only")
    print("  -n <NUM>, --numRuns=<NUM>     Number of runs")
    print("  -d <STR>, --runDir=<STR>      Directory of the test case")
    print("--------------------------------------------------")
    print("  -h, --help                    Help")
    print("  -v, --verbose                 Verbose")
    sys.exit(exitCode)

  def readArgs(self,a_argv):
    """ Perform the getopt parsing """
    longArgs = [
        "bin=",
        "testFile=",
        "numRuns=",
        "runDir=",
        "forceSeed=",
        "randScript=",
        "preRun=",
        "postRun=",
        "testSuffix=",
        "extraArgs=",
      ]
    try:
      opts, remainder = getopt.getopt(a_argv,"hvb:t:n:d:F:r:P:p:z:x:",longArgs)
    except getopt.GetoptError:
      self.printHelp(2)

    for opt, arg in opts:
      if   opt in ("-h","--help"):       self.printHelp(0)
      elif opt in ("-v","--verbose"):    self.opt_verbose    = True
      elif opt in ("-b","--bin"):        self.opt_bin        = arg
      elif opt in ("-t","--testFile"):   self.opt_testFile   = arg
      elif opt in ("-n","--numRuns"):    self.opt_numRuns    = int(arg)
      elif opt in ("-d","--runDir"):     self.opt_runDir     = arg
      elif opt in ("-F","--forceSeed"):  self.opt_forceSeed  = int(arg)
      elif opt in ("-r","--randScript"): self.opt_randScript = arg
      elif opt in ("-P","--preRun"):     self.opt_preRun     = arg
      elif opt in ("-p","--postRun"):    self.opt_postRun    = arg
      elif opt in ("-z","--testSuffix"): self.opt_testSuff   = arg
      elif opt in ("-x","--extraArgs"):  self.opt_exArgs     = arg
      else:
        print("Unknown option %s" % opt)

    # Option checking
    #
    if not self.opt_testSuff.strip():   # Suffix correction
      print "\nERROR: empty test suffix not supported!!!"
      sys.exit(-9)
    else:
      if self.opt_testSuff[0] != '.':
        self.opt_testSuff = '.' + self.opt_testSuff
    if self.opt_testFile is not None:   # Verify Test File has suffix -- or add if no suffix
      l_dotPos   = self.opt_testFile.rfind('.')
      if l_dotPos < 0:
        self.opt_testFile = self.opt_testFile + self.opt_testSuff
      else:
        if self.opt_testSuff != self.opt_testFile[l_dotPos:]:
          print "\nERROR: test file '%s' has incorrect suffix!!! expected: '%s'" %(self.opt_testFile,self.opt_testSuff)
          sys.exit(-2)

    # Determine the test label here
    remLen = len(remainder)
    if remLen == 0: self.testLabel = self.inferTestLabel()  # TODO: fix this function to use opt_runDir
    else:           self.testLabel = self.preCheckLabel(remainder)

    if True:    # self.opt_verbose
      if self.opt_bin        is not None: print("- opt_bin       : %s" % self.opt_bin       )
      if self.opt_testFile   is not None: print("- opt_testFile  : %s" % self.opt_testFile  )
      if self.opt_numRuns    is not None: print("- opt_numRuns   : %d" % self.opt_numRuns   )
      if self.opt_runDir     is not None: print("- opt_runDir    : %s" % self.opt_runDir    )
      if self.opt_forceSeed  is not None: print("- opt_forceSeed : %d" % self.opt_forceSeed )
      if self.opt_randScript is not None: print("- opt_randScript: %s" % self.opt_randScript)
      if self.opt_preRun     is not None: print("- opt_preRun    : %s" % self.opt_preRun    )
      if self.opt_postRun    is not None: print("- opt_postRun   : %s" % self.opt_postRun   )
      if self.opt_testSuff   is not None: print("- opt_testSuff  : %s" % self.opt_testSuff  )
      if self.opt_exArgs     is not None: print("- opt_exArgs    : %s" % self.opt_exArgs    )
      if self.testLabel      is not None: print("- testLabel     : %s" % self.testLabel     )

  def inferTestLabel(self):
    """ Try to figure out test label
        1- if testFile specified, use it
        2- find <CWD>.<TEST_SUFF> in local directory ---> TEST_LABEL = basename(pwd)
        3- find <TEST_LABEL>.<TEST_SUFF> in local directory
        NOTE: self.opt_testFile ends up being defined either way
    """
    self.testLabelInferred = True
    if self.opt_testFile is not None:
      fileStr = self.opt_testFile[:len(self.opt_testFile)-len(self.opt_testSuff)]
      return fileStr
    bpwd = basename(self.e_cwd)
    if os.path.isfile(bpwd + self.opt_testSuff):
      self.opt_testFile = bpwd + self.opt_testSuff
      return bpwd
    fileList = [oneF for oneF in os.listdir('.') if os.path.isfile(oneF) and oneF.endswith(self.opt_testSuff)]
    if len(fileList) == 1:
      # Strip out the suffix
      self.opt_testFile = fileList[0]
      fileStr = self.opt_testFile[:len(self.opt_testFile)-len(self.opt_testSuff)]
      return fileStr
    print "ERROR: couldn't figure out test case"
    sys.exit(-6)

  def preCheckLabel(self,argLst):
    """ Preliminary checking of testLabel argument """
    l_label = argLst[0]
    if len(argLst) > 1:
      print "WARNING: multiple labels not supported at this time!"
    if l_label == '.':
      l_label = self.inferTestLabel()
    # For standalone labels
    # - Perhaps rename self.testLabelInferred variable
    if os.path.isfile(l_label + self.opt_testSuff):
      self.testLabelInferred = True
      self.opt_testFile      = l_label + self.opt_testSuff
    return l_label

  #-----------------------------------------------------------------------------
  def loadTestConfig(self):
    """ Loads *.TL files
        Load default.TL file
    """
    if self.opt_verbose:
      print("\n[launcher::loadTestConfig()]\n")

    # Check script's CWD
    l_lwdTest = self.e_lwd + '/test'
    if l_lwdTest != self.e_cwd[:len(l_lwdTest)]:
      print "\nERROR: %s must be invoked under %s* !!!" %(basename(self.progName),l_lwdTest)
      print "  CWD: %s" %self.e_cwd
      sys.exit(-1)
    if self.opt_verbose:
      print "  CWD:   %s" %self.e_cwd
      print "  Local: %s" %self.e_lwd

    load_testList = []
    def_testList  = []

    # Find regular TL files in the expected locations
    #
    rootDir = '.'
    for dirName, subdirList, fileList in os.walk(rootDir):
      # modify subdirList to skip unwanted subdirectories
      # Note: os.walk flattens the structure
      #
      if 'CVS' in subdirList:
        subdirList.remove('CVS') # TODO: add other names to be skipped programatically

      for fname in fileList:
        if '.' in fname:
          fBase, fExt = os.path.splitext(fname)
          if fBase != 'default' and fExt == '.tl':
            load_testList.append(dirName + '/' + fname)

    # Find the default TL file -- only one
    #
    endStr  = None
    srchStr = self.e_cwd[len(l_lwdTest):]
    slPos   = srchStr.find('/')

    if slPos < 0:
      endStr = self.e_cwd
    else:
      endStr = self.e_cwd[:len(l_lwdTest)+slPos]
    if self.opt_verbose:
      print "  - For default.tl, end at %s" % endStr

    checkDir  = self.e_cwd
    fileFound = False
    while True:
      filePath  = checkDir + '/default.tl'
      fileFound = os.path.isfile(filePath)
      if fileFound:
        def_testList.append(filePath )
        print "  * Found: %s" % filePath
        break
      slPos = checkDir.rfind('/')
      checkDir = checkDir[:slPos]
      # A lexicographic comparison would be better than length comparison
      # If equal, there should be one more iteration
      if len(checkDir) < len(endStr):
        break
    assert (len(def_testList)) < 2  # Only 1 default testList supported for now

    # Debug printing
    #
    if self.opt_verbose:
      if len(load_testList) == 0:
        print "\n  No *.tl found!"
      else:
        print "\n  *.tl to be loaded:"
        for fname in load_testList:
          print "  - %s" % fname
      if len(def_testList) == 0:
        print "  No default.tl found!"
      else:
        print "  default.tl to be loaded:"
        for fname in def_testList:
          print "  - %s" % fname
    print ''

    # Find regular TL files in the expected locations
    #
    for fname in load_testList:
      self.cfg_testList.append( self.tlClass(fileName=fname,dirPath=self.e_cwd,verb=self.opt_verbose,origin=self) )
    for fname in def_testList:
      self.cfg_defList.append( self.tlDefault(fileName=fname,dirPath=self.e_cwd,verb=self.opt_verbose,origin=self) )

    if len(def_testList) > 0:   # Fix self.cfg_defList defaults
      if self.cfg_defList[0].defTestValues.bin        is not None: self.cfg_defList[0].defTestValues.bin        = self.cfg_defList[0].defTestValues.bin[0]
      if self.cfg_defList[0].defTestValues.testFile   is not None: self.cfg_defList[0].defTestValues.testFile   = self.cfg_defList[0].defTestValues.testFile[0]
      if self.cfg_defList[0].defTestValues.numRuns    is not None: self.cfg_defList[0].defTestValues.numRuns    = self.cfg_defList[0].defTestValues.numRuns[0]
      if self.cfg_defList[0].defTestValues.forceSeed  is not None: self.cfg_defList[0].defTestValues.forceSeed  = self.cfg_defList[0].defTestValues.forceSeed[0]
      if self.cfg_defList[0].defTestValues.randScript is not None: self.cfg_defList[0].defTestValues.randScript = self.cfg_defList[0].defTestValues.randScript[0]
      if self.cfg_defList[0].defTestValues.preRun     is not None: self.cfg_defList[0].defTestValues.preRun     = self.cfg_defList[0].defTestValues.preRun[0]
      if self.cfg_defList[0].defTestValues.postRun    is not None: self.cfg_defList[0].defTestValues.postRun    = self.cfg_defList[0].defTestValues.postRun[0]
      if self.cfg_defList[0].defTestValues.exArgs     is not None: self.cfg_defList[0].defTestValues.exArgs     = self.cfg_defList[0].defTestValues.exArgs[0]

  def analyzeTestConfig(self):
    """ Perform the following
        - Propagate some command line settings to default settings
        - Propagate default settings to each list
        - Load all ID's TestNames, Groups and *.tl names too
          - Also, perform test case sanity checking
          - All TestNames must be unique
          - Group names must not collide with TestNames
        NOTE:
           a) Other checking is deferred to when retrieving test list
           b) *.tl doesn't need to be unique
             i)  TL files will be the last to be searched if neither ID is TestName nor Group
             ii) Just run the first one found -- if multiple TL files have the same name, that's the user's problem
    """

    # 1- propagate command line settings to default values
    #    values passed in by command line has priority
    #
    if len(self.cfg_defList) == 0:
      addDef = False
      if self.opt_bin        is not None: addDef = True
      if self.opt_forceSeed  is not None: addDef = True
      if self.opt_randScript is not None: addDef = True
      if self.opt_preRun     is not None: addDef = True
      if self.opt_postRun    is not None: addDef = True
      if self.opt_exArgs     is not None: addDef = True
      if addDef:
        self.cfg_defList.append( self.tlDefault(fileName=None,dirPath=None,verb=self.opt_verbose,origin=self) )

    if len(self.cfg_defList) > 0:
      if self.opt_bin        is not None: self.cfg_defList[0].defTestValues.bin        = self.opt_bin
      if self.opt_forceSeed  is not None: self.cfg_defList[0].defTestValues.forceSeed  = self.opt_forceSeed
      if self.opt_randScript is not None: self.cfg_defList[0].defTestValues.randScript = self.opt_randScript
      if self.opt_preRun     is not None: self.cfg_defList[0].defTestValues.preRun     = self.opt_preRun
      if self.opt_postRun    is not None: self.cfg_defList[0].defTestValues.postRun    = self.opt_postRun
      if self.opt_exArgs     is not None: self.cfg_defList[0].defTestValues.exArgs     = self.opt_exArgs

    # 2- propagate default settings to each Test List
    #
    if len(self.cfg_defList) > 0:
      for oneTl in self.cfg_testList:
        for oneTest in oneTl.tstObjLst:
          oneTest.pullIntrospect(self.cfg_defList[0].defTestValues)


    # 3- Load all ID's
    #   - Include test case sanity check
    #
    l_tlFileNameList = []   # Local list of file names
    for oneTl in self.cfg_testList:
      for oneTest in oneTl.tstObjLst:
        # Basic checks -- TODO: convert these to proper error messages (use a function)
        assert oneTest.bin      is not None
        assert oneTest.testName is not None
        assert oneTest.testFile is not None
        assert oneTest.numRuns  is not None
        assert oneTest.runDir   is not None
        if oneTest.testName in self.collectId_name:
          print "ERROR: Duplicate Test Name '%s' found in %s!" %(oneTest.testName,oneTl.fileName)
          sys.exit(106)
        self.collectId_name.append(oneTest.testName)

        # Go thru groups of the given test
        # - Check that group names don't collide with test names
        for oneGrp in oneTest.groupList:
          if oneGrp in self.collectId_name:
            print "ERROR: group name '%s' found in '%s' already exists as a Test Name!!!" %(oneGrp,oneTl.fileName)
            sys.exit(110)
          self.collectId_group[oneGrp].append(oneTest)

      if oneTl.tlName in l_tlFileNameList:
        self.duplicateTlFn[oneTl.tlName] = 1
      else:
        l_tlFileNameList.append(oneTl.tlName)

    if self.opt_bin is None:
      self.opt_bin = 'runDelaySecs'  # TEMP for debugging -- TODO

  #-----------------------------------------------------------------------------
  def searchTestList(self,labelId):
    """ Search for the given label
        1- Test Names
        2- Groups
        3- TL Files
    """
    retList = None

    if labelId in self.collectId_name:
      # Test Name
      for oneTl in self.cfg_testList:
        for oneTest in oneTl.tstObjLst:
          if labelId == oneTest.testName:
            retList = [oneTest]
            break

    if retList is None:
      if labelId in self.collectId_group.keys():
        # Group
        retList = self.collectId_group[labelId]

    if retList is None:
      if labelId in self.duplicateTlFn.keys():
        print "ERROR: label '%s' -- but multiple %s.tl found!!!" %(labelId,labelId)
        sys.exit(111)
      for oneTl in self.cfg_testList:
        if labelId == oneTl.tlName:
          # TL File
          retList = oneTl.tstObjLst
          break

    if (retList is None) or (len(retList) == 0):
      return None
    return retList

  #-----------------------------------------------------------------------------
  def getTestList(self):
    """ Returns a list of tests associated with the given label
        1- Find testLabel in test classes
        2- Find testLabel in test names
        3- Find testLabel as test file in local directory
    """

    l_testList = None

    # Get Test List from TL files -- perform a search
    #
    if len(self.cfg_testList) > 0:
      l_testList = self.searchTestList(self.testLabel)

    # No corresponding tests found, try local test
    #
    if l_testList == None:
      if self.testLabelInferred:
        l_testList = self.getLocalTest()
      else:
        print '\nERROR: No tests to run!'
        print '--------------------------------------------------'
        self.printHelp(7)

    return l_testList

  def getLocalTest(self):
    """ For local tests, formulate a list of one object using the options provided """
    l_testList = []

    # Both self.opt_testFile and testLabel should be defined
    #
    assert self.opt_testFile is not None
    assert self.testLabel    is not None

    tcArgDict = {
        'bin'        : self.opt_bin,
        'testName'   : self.testLabel,
        'testFile'   : self.opt_testFile,
        'numRuns'    : self.opt_numRuns,
        'runDir'     : self.opt_runDir,
        'forceSeed'  : self.opt_forceSeed,
        'randScript' : self.opt_randScript,
        'preRun'     : self.opt_preRun,
        'postRun'    : self.opt_postRun,
        'exArgs'     : self.opt_exArgs
      }

    aTest = self.testClass(**tcArgDict)
    if len(self.cfg_defList) > 0:
      aTest.pullIntrospect(self.cfg_defList[0].defTestValues)   # introspect values from default.TL
    aTest.printMembers()

    l_testList.append(aTest)

    return l_testList

  def checkTestList(self,runObjList):
    """Check each test in the run list
       - Check the bin + create a map: bin name --> bin full path
       - Check test file

      # Pre-run sanity checking
      # - remove tests with numRuns < 1
      # - all scripts exists
    """
    # Check binaries
    for oneTest in runObjList:
      self.binFullPaths[oneTest.bin] = 'UNDEFINED'
    for oneBin in self.binFullPaths.keys():
      whichBin = subprocess.Popen(['which',oneBin],shell=False,stdout=subprocess.PIPE,preexec_fn=os.setsid)
      binPath  = whichBin.stdout.read().strip()
      if len(binPath) < 1:
        sys.stderr.write("ERROR: executable '%s' not found in path" % oneBin)
        sys.exit(112)
      self.binFullPaths[oneBin] = binPath

    # Check test file
    for oneTest in runObjList:
      filePath  = self.e_cwd + '/' + oneTest.runDir + '/' + oneTest.testFile
      fileCheck = os.path.isfile(filePath)
      if not fileCheck:     # TODO: this should actually be an error -- warning for now (or as an option)
        print "WARNING: Test File '%s' not found!!!\n----> %s" % (oneTest.testFile,filePath)

    # Remove tests with numRuns < 1
    #

    # All scripts exists
    #

    # Debug Printouts
    #
    doPrint = True
    if doPrint:
      print '\n  + ----------------------------- Finalized Values Print'
      for oneTest in runObjList:
        oneTest.printMembers()
      print '  + ----------------------------- Done Finalized Values'

  #-----------------------------------------------------------------------------
  def launchTest(self,oneTest,idx):
    """ Prepares and launches the test
        - Run directory created here in order to avoid name collision
        - Get the argument array from testClass
        - Creates the child process
        NOTE: Operates on one instance of a test, index is provided
    """

    def launchCheckTest(testObj,runIdx):
      """ Checks the configuration before launching """
      if testObj.bin is None:
        sys.stderr.write("ERROR: couldn't figure out binary file")
        sys.exit(103)

    def genRunDir(testObj,runIdx):
      """ Creates the run directory """
      runDir = testObj.runDir # TODO: expand to full path -- os.path.abspath()?
      i = 0
      while True:
        newDir = "%s/RUN.%s.%s.%d" %(runDir,testObj.bin,testObj.testName,i)
        if not os.path.isdir(newDir):
          break
        i += 1
      print "  +   Create dir: %s" %newDir
      os.makedirs(newDir)
      oneTest.actualRunDir = newDir

      walkDir = self.e_cwd + '/' + runDir
      walkOff = len(walkDir)
      print "  +   walkDir: %s" %walkDir
      for dirName, subdirList, fileList in os.walk(walkDir):
        # modify subdirList to skip unwanted subdirectories
        # Note: os.walk flattens the structure
        #
        if len(dirName) > walkOff:
          continue
        else:
          l_dirName = ''

        if 'CVS' in subdirList:
          subdirList.remove('CVS') # TODO: add other names to be skipped programatically
        l_RUNDir = []
        for aDir in subdirList:
          if aDir.find('RUN.') == 0:
            l_RUNDir.append(aDir)
        for aDir in l_RUNDir:
          subdirList.remove(aDir)

        # Create symbolic links
        for fname in fileList:
          os.symlink( '../' + fname, newDir + '/' + fname)      #os.symlink( walkDir + '/' + fname, newDir + '/' + fname)
        for aDir in subdirList:
          os.symlink( '../' + aDir, newDir + '/' + aDir)        #os.symlink( walkDir + '/' + aDir, newDir + '/' + aDir)

      return newDir

    def createLog(logName,cmdLst,refTC):
      """ Creates the executable's log file and writes preliminary info """
      try:
        logHand = open(logName,'w')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %logName)
        sys.exit(104)
      logHand.write('%s\n' % cmdLst)
      logHand.write('%s\n' % datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))
      logHand.write('--------------------------------------------------\n')
      refTC.printMembers(logHand)
      logHand.write('--------------------------------------------------\n\n')
      logHand.close()

    def runLaunchDelegate(cmdLaunch,runDir,refTestClass):
      """ Launches the actual process and returns the proc object
          NOTE:
            run.log    - executable's log file; set in self.runLogName
            launch.log - the launcher script's log file
                       - hardcoded file name cannot be changed
                       - contains metadata for pre/post scripts
      """
      launchLogName = runDir + '/launch.log'
      try:
        launchLogHand = open(launchLogName,'w')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %launchLogName)
        sys.exit(105)
      global g_launchScr
      l_cmd = [g_launchScr] + cmdLaunch + ["--logFile=" + self.runLogName]
      #
      # Call createLog here to print the final values for the command
      #
      createLog(runDir + "/" + self.runLogName,l_cmd,refTestClass)
      print "  +   %s" % l_cmd
      delgProc = subprocess.Popen(l_cmd, stdout=launchLogHand, stderr=launchLogHand, shell=False, preexec_fn=os.setsid, cwd=runDir)
      return delgProc
    #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    launchCheckTest(oneTest,idx)

    # 1- Create run directory here in order to avoid name collision
    #
    targetDir = genRunDir(oneTest,idx)

    # 2- Get command array from class
    #
    cmdArray = oneTest.getCmdArray(self)

    # 3- Launch process; redirect both STDOUT and STDERR to log file
    # Note:
    #   http://stackoverflow.com/questions/18344932/python-subprocess-call-stdout-to-file-stderr-to-file-display-stderr-on-scree
    # Long Term:
    #   Have the option to redirect STDERR to its own file
    #   Have the option to re-run the test
    subProc = runLaunchDelegate(cmdArray,targetDir,oneTest)
    print "  +"

    return subProc

  #-----------------------------------------------------------------------------
  def run(self):
    """ The main function of this class
        1- Search for any *.tl within current directory tree
           Search for default.tl until top-level test tree: ${LOCAL_WS_DIR}/test*
        2- Figure out testLabel:
          a) Standalone (not in *.tl)
          b) Test Name
          c) Test Class
        3- Launch tests and wait for child processes to complete, print every <DELAY> secs
    """

    if self.opt_verbose:
      print "\n[launcher::run()]\n"

    # 1- Load test lists / config
    #
    self.loadTestConfig()
    self.analyzeTestConfig()

    # 2- Get test list from test label
    #
    self.runList = self.getTestList()
    self.checkTestList(self.runList)

      #
      #  TODO: create standalone interactive mode -- default if there's only one test
      #
      #if len(runList) == 1 and numRuns == 1
      #  os.system(self.runList[0].bin)
      #  return

    #
    # 3- Combined Launch and Wait
    #
    if self.opt_verbose:
      print "\n*\n* Run List size: %d\n*" % len(self.runList)

    global g_maxThreads
    global g_sleepDelay
    global g_proc

    g_proc      = []
    l_runTrkLst = []
    l_maxIdStr  = 0

    numPend  = 0
    numRun   = 0
    numDone  = 0

    for testObj in self.runList:
      #
      # Expand each test into separate instances
      #
      for idx in range(testObj.numRuns):
        runIdStr = '%s_%d' % (testObj.testName,idx)
        l_runTrkLst.append( self.runTracker(testObj=testObj,runStr=runIdStr,idx=idx) )

        if len(runIdStr) > l_maxIdStr:
          l_maxIdStr = len(runIdStr)

    prnIdFmt = '{0: <'   + str(l_maxIdStr) + '}'
    prnStFmt = '{0: <'   + str(10) + '}'
    prnRsFmt = ': {0: <' + str(16) + '}'
    numTotal = len(l_runTrkLst)
    numPend  = numTotal

    if self.opt_verbose:
      print "\n*\n* Total tests to be launched: %d\n*" % numTotal

    # Combined launch and wait loop here
    #
    l_doLoop = True if numPend > 0 else False   # Don't enter the loop if no tests to run
    while l_doLoop:
      assert numTotal == (numPend + numRun + numDone)

      # Poll tests
      #
      for pollObj in l_runTrkLst:
        if pollObj.state == 'Running':
          if pollObj.proc.poll() is not None:
            pollObj.state  = 'Done'
            pollObj.result = 'Unknown'
            numRun  = numRun  - 1
            numDone = numDone + 1

            # Get the result -- if file exists, read and delete
            #
            runResFN =  pollObj.testObj.actualRunDir  + '/' + self.runResultFile
            if self.opt_verbose:
              print "\n  ~\n  ~ Test '%s' finished!\n  ~ Checking on file %s\n  ~" %(pollObj.runStr,runResFN)
              if os.path.isfile(runResFN):
                with open(runResFN,'r') as runResFH:
                  read_resStr = runResFH.read().strip().lower()
                  if 'pass' in read_resStr: pollObj.result = 'Passed'
                  if 'fail' in read_resStr: pollObj.result = 'Failed'
                os.remove(runResFN)

      # Launch tests
      #
      while (numRun < g_maxThreads) and (numPend > 0):
        launFiltLst = filter(lambda lObj : lObj.state == 'Pending', l_runTrkLst)
        assert len(launFiltLst) > 0
        launchTrObj = launFiltLst[0]

        print '\n  ++++++++++++++++++++++ Launching %s\n  +' % launchTrObj.runStr
        launch_proc = self.launchTest(launchTrObj.testObj,launchTrObj.idx)
        g_proc.append( launch_proc )

        launchTrObj.state = 'Running'
        launchTrObj.proc  = launch_proc
        numPend = numPend - 1
        numRun  = numRun  + 1

      # Print
      #
      print "\n\n\n"
      print "|---------------------------------------"
      print "| Polling Tests [%s]" %datetime.now().strftime('%Y-%m-%d %H:%M:%S')
      print "| Pending: %d, Running: %d, Done: %d" %(numPend,numRun,numDone)
      print "| ++++++++++++++++++++++++++++++++++++++"
      print "|"
      for prnObj in l_runTrkLst:
        prnIdent = prnIdFmt.format(prnObj.runStr)
        prnState = prnStFmt.format(prnObj.state)
        prnRslt  = prnRsFmt.format(prnObj.result) if prnObj.state == 'Done' else ''
        print "| %s : %s %s" %(prnIdent,prnState,prnRslt)
      print "|"
      print "|---------------------------------------"

      # Loop exit check
      #
      if (numPend == 0) and (numRun == 0) and (numDone == numTotal):
        break

      # Sleep
      #
      time.sleep(g_sleepDelay)


  #-----------------------------------------------------------------------------
  @atexit.register
  def launcherCleanup():
    """ Kill any remaining child processes here
        - Invoked when program is terminating (via SIGKILL or finishing naturally)
    """
    global g_proc
    if g_proc is not None:
      pidKillList = []
      sys.stdout.flush()
      sys.stderr.write( "\n[launcherCleanup()]\n" )

      for oneProc in g_proc:
        if oneProc.poll() is None:
          sys.stderr.write( "- killing subprocess [pid=%d]\n" %oneProc.pid )
          pidKillList.append(oneProc.pid)
          oneProc.send_signal(signal.SIGINT)

      for onePid in pidKillList:
        os.killpg(onePid,signal.SIGTERM)
      sys.stderr.write( "\n\n" )
    #
    # Question: Should we save the launch log file handles and close them here?
    #


#-------------------------------------------------------------------------------

def initGlob():
  """ Init Global variables """
  global g_tcPars
  g_tcPars = argparse.ArgumentParser()
  g_tcPars.add_argument('-b', '--bin',        nargs=1,   dest='bin',                               help='Executable Program')
  g_tcPars.add_argument('-N', '--testName',   nargs=1,   dest='testName',                          help='Test name')
  g_tcPars.add_argument('-f', '--testFile',   nargs=1,   dest='testFile',                          help='Test file')
  g_tcPars.add_argument('-n', '--numRuns',    nargs=1,   dest='numRuns',    type=int, default=1,   help='Number of runs')
  g_tcPars.add_argument('-d', '--runDir',     nargs=1,   dest='runDir',               default='.', help='Directory which will contain the run directories')
  g_tcPars.add_argument('-F', '--forceSeed',  nargs=1,   dest='forceSeed',  type=int,              help='Forcibly override random seed')
  g_tcPars.add_argument('-r', '--randScript', nargs=1,   dest='randScript',                        help='Specify random seed generator script')
  g_tcPars.add_argument('-P', '--preRun',     nargs=1,   dest='preRun',                            help='Comma-separated list of pre-run scripts')
  g_tcPars.add_argument('-p', '--postRun',    nargs=1,   dest='postRun',                           help='Comma-separated list of post-run scripts')
  g_tcPars.add_argument('-x', '--extraArgs',  nargs='+', dest='extraArgs',                         help='Arguments for the executable')

  global g_defPars  # mostly same arguments, no default values
  g_defPars = argparse.ArgumentParser()
  g_defPars.add_argument('-b', '--bin',        nargs=1,   dest='bin',                              help='Executable Program')
  g_defPars.add_argument('-f', '--testFile',   nargs=1,   dest='testFile',                         help='Test file')
  g_defPars.add_argument('-n', '--numRuns',    nargs=1,   dest='numRuns',    type=int,             help='Number of runs')
  g_defPars.add_argument('-F', '--forceSeed',  nargs=1,   dest='forceSeed',  type=int,             help='Forcibly override random seed')
  g_defPars.add_argument('-r', '--randScript', nargs=1,   dest='randScript',                       help='Specify random seed generator script')
  g_defPars.add_argument('-P', '--preRun',     nargs=1,   dest='preRun',                           help='Comma-separated list of pre-run scripts')
  g_defPars.add_argument('-p', '--postRun',    nargs=1,   dest='postRun',                          help='Comma-separated list of post-run scripts')
  g_defPars.add_argument('-x', '--extraArgs',  nargs='+', dest='extraArgs',                        help='Arguments for the executable')

#-------------------------------------------------------------------------------

if __name__ == "__main__":
  initGlob()
  launObj = launcher()
  launObj.setProgName( sys.argv[0]  )
  launObj.readArgs   ( sys.argv[1:] )
  launObj.run        ()

