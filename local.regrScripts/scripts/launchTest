#!/usr/bin/python
#-------------------------------------------------------------------------------
# Copyright (c) 2015 manxinator
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#-------------------------------------------------------------------------------
# launchTest
# Author:   manxinator
# Created:  Wed Oct  7 02:28:49 PDT 2015
# Language: Python 2.7.6
#-------------------------------------------------------------------------------

import os, sys, getopt
import signal, subprocess, time
import atexit
from datetime import datetime
from os.path import basename

g_proc = None

#-------------------------------------------------------------------------------
class launcher:
  """Launcher class is a top level regressable script"""

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class testClass:
    def __init__(self,**kwargs):
      self.bin        = None
      self.testName   = None
      self.testFile   = None
      self.numRuns    = None
      self.runDir     = None
      self.forceSeed  = None
      self.randScript = None
      self.preRun     = None
      self.postRun    = None
      self.exArgs     = None
      if kwargs is not None:
        if 'bin'        in kwargs: self.bin        = kwargs['bin'       ]
        if 'testName'   in kwargs: self.testName   = kwargs['testName'  ]
        if 'testFile'   in kwargs: self.testFile   = kwargs['testFile'  ]
        if 'numRuns'    in kwargs: self.numRuns    = kwargs['numRuns'   ]
        if 'runDir'     in kwargs: self.runDir     = kwargs['runDir'    ]
        if 'forceSeed'  in kwargs: self.forceSeed  = kwargs['forceSeed' ]
        if 'randScript' in kwargs: self.randScript = kwargs['randScript']
        if 'preRun'     in kwargs: self.preRun     = kwargs['preRun'    ]
        if 'postRun'    in kwargs: self.postRun    = kwargs['postRun'   ]
        if 'exArgs'     in kwargs: self.exArgs     = kwargs['exArgs'    ]

    #def dummy(self,a_bin,a_tn,xArg,forceSeed):
    #  self.bin      = a_bin
    #  self.testName = a_tn
    #  self.testFile = a_tn + self.testSuff
    #  self.numRuns  = 1
    #  self.runDir   = '.'
    #  self.exArgs   = xArg
    #  if forceSeed is not None:
    #    self.forceSeed = forceSeed

    def getCmdArray(self):
      whichBin = subprocess.Popen(['which',self.bin],shell=False,stdout=subprocess.PIPE,preexec_fn=os.setsid)
      binPath  = whichBin.stdout.read().strip()
      retArray = [binPath]
      if self.randScript is not None: retArray = retArray + ["--randScript=" + self.randScript]
      if self.forceSeed  is not None: retArray = retArray + ["--forceSeed=%d" % self.forceSeed]
      if self.preRun     is not None: retArray = retArray + ["--preRun=%s"    % self.preRun]
      if self.postRun    is not None: retArray = retArray + ["--postRun=%s"   % self.postRun]
      if self.testFile   is not None: retArray = retArray + ["--testFile="  + self.testFile]
      if self.exArgs     is not None: retArray = retArray + ["--extraArgs=" + self.exArgs]
      return retArray
  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

  def __init__(self):
    """Initialization for launcher class"""
    self.progName = None

    self.opt_verbose     = True
    self.opt_bin         = None
    self.opt_testFile    = None       # currently, only used in self.inferTestLabel()
    self.opt_numRuns     = 1
    self.opt_runDir      = '.'
    self.opt_forceSeed   = None
    self.opt_randScript  = None
    self.opt_preRun      = None
    self.opt_postRun     = None
    self.opt_testSuff    = ".aok"
    self.opt_exArgs      = None
    self.testLabel       = None

    self.e_cwd = None
    self.e_lwd = None

    self.testLabelInferred = False
    self.runLogName        = "run.log"   # Perhaps make this programmable

  def setProgName(self,a_progName):
    """ Sets program name for printing -- may be cleaned up: basename, etc. """
    self.progName = a_progName

  def printHelp(self,exitCode):
    """ Prints the help instructions and exits. """
    print("Usage: %s [OPTIONS] TEST_LABEL" % basename(self.progName))
    print("  -b <STR>, --bin=<STR>         Executable binary")
    print("  -t <STR>, --testFile=<STR>    Specify test file")
    print("                                - only used when TEST_LABEL not defined")
    print("                                - standalone test only")
    print("  -n <NUM>, --numRuns=<NUM>     Number of runs")
    print("  -d <STR>, --runDir=<STR>      Directory which will contain the run directories")
    print("  -F <NUM>, --forceSeed=<NUM>   Run test with given random seed")
    print("  -r <STR>, --randScript=<STR>  Specify random seed generator script")
    print("  -P <STR>, --preRun=<STR>      Comma-separated list of pre-run scripts")
    print("  -p <STR>, --postRun=<STR>     Comma-separated list of post-run scripts")
    print("  -z <STR>, --testSuffix=<STR>  Specify test suffix; defaults to '.aok'")
    print("  -x <STR>, --extraArgs=<STR>   Additional arguments")
    print("--------------------------------------------------")
    print("  -h, --help                    Help")
    print("  -v, --verbose                 Verbose")
    sys.exit(exitCode)

  def readArgs(self,a_argv):
    longArgs = [
        "bin=",
        "testFile=",
        "numRuns=",
        "runDir=",
        "forceSeed=",
        "randScript=",
        "preRun=",
        "postRun=",
        "testSuffix=",
        "extraArgs=",
      ]
    try:
      opts, remainder = getopt.getopt(a_argv,"hvb:t:n:d:F:r:P:p:z:x:",longArgs)
    except getopt.GetoptError:
      self.printHelp(2)

    for opt, arg in opts:
      if   opt in ("-h","--help"):       self.printHelp(0)
      elif opt in ("-v","--verbose"):    self.opt_verbose    = True
      elif opt in ("-b","--bin"):        self.opt_bin        = arg
      elif opt in ("-t","--testFile"):   self.opt_testFile   = arg
      elif opt in ("-n","--numRuns"):    self.opt_numRuns    = int(arg)
      elif opt in ("-d","--runDir"):     self.opt_runDir     = arg
      elif opt in ("-F","--forceSeed"):  self.opt_forceSeed  = int(arg)
      elif opt in ("-r","--randScript"): self.opt_randScript = arg
      elif opt in ("-P","--preRun"):     self.opt_preRun     = arg
      elif opt in ("-p","--postRun"):    self.opt_postRun    = arg
      elif opt in ("-z","--testSuffix"): self.opt_testSuff   = arg
      elif opt in ("-x","--extraArgs"):  self.opt_exArgs     = arg
      else:
        print("Unknown option %s" % opt)

    if not self.opt_testSuff.strip():
      print "\nERROR: empty test suffix not supported!!!"
      sys.exit(-9)
    else:
      if self.opt_testSuff[0] != '.':
        self.opt_testSuff = '.' + self.opt_testSuff

    # Determine the test label here
    remLen = len(remainder)
    if remLen == 0: self.testLabel = self.inferTestLabel()
    else:           self.testLabel = self.preCheckLabel(remainder)

    if True:    # self.opt_verbose
      if self.opt_bin        is not None: print("- opt_bin       : %s" % self.opt_bin       )
      if self.opt_testFile   is not None: print("- opt_testFile  : %s" % self.opt_testFile  )
      if self.opt_numRuns    is not None: print("- opt_numRuns   : %d" % self.opt_numRuns   )
      if self.opt_runDir     is not None: print("- opt_runDir    : %s" % self.opt_runDir    )
      if self.opt_forceSeed  is not None: print("- opt_forceSeed : %d" % self.opt_forceSeed )
      if self.opt_randScript is not None: print("- opt_randScript: %s" % self.opt_randScript)
      if self.opt_preRun     is not None: print("- opt_preRun    : %s" % self.opt_preRun    )
      if self.opt_postRun    is not None: print("- opt_postRun   : %s" % self.opt_postRun   )
      if self.opt_testSuff   is not None: print("- opt_testSuff  : %s" % self.opt_testSuff  )
      if self.opt_exArgs     is not None: print("- opt_exArgs    : %s" % self.opt_exArgs    )
      if self.testLabel      is not None: print("- testLabel     : %s" % self.testLabel     )

  def inferTestLabel(self):
    """Try to figure out test label
       1- if testFile specified, use it
       2- find <CWD>.<TEST_SUFF> in local directory ---> TEST_LABEL = basename(pwd)
       3- find <TEST_LABEL>.<TEST_SUFF> in local directory
       NOTE: self.opt_testFile ends up being defined either way
    """
    self.testLabelInferred = True
    if self.opt_testFile is not None:
      fileStr = self.opt_testFile[:len(self.opt_testFile)-len(self.opt_testSuff)]
      return fileStr
    bpwd = basename(os.environ.get('PWD'))
    if os.path.isfile(bpwd + self.opt_testSuff):
      self.opt_testFile = bpwd + self.opt_testSuff
      return bpwd
    fileList = [oneF for oneF in os.listdir('.') if os.path.isfile(oneF) and oneF.endswith(self.opt_testSuff)]
    if len(fileList) == 1:
      # Strip out the suffix
      self.opt_testFile = fileList[0]
      fileStr = self.opt_testFile[:len(self.opt_testFile)-len(self.opt_testSuff)]
      return fileStr
    print "ERROR: couldn't figure out test case"
    sys.exit(-6)

  def preCheckLabel(self,argLst):
    """Preliminary checking of testLabel argument"""
    l_label = argLst[0]
    if len(argLst) > 1:
      print "WARNING: multiple labels not supported at this time!"
    if l_label == '.':
      l_label = self.inferTestLabel()
    return l_label

  #-----------------------------------------------------------------------------
  def loadTestConfig(self):
    """Loads test list files
    """
    if self.opt_verbose:
      print("\n[launcher::loadTestConfig()]\n")
    self.e_cwd = os.getcwd().rstrip('/')
    self.e_lwd = os.environ['LOCAL_WS_DIR'].rstrip('/')

    # Check script's CWD
    l_lwdTest = self.e_lwd + '/test'
    if l_lwdTest != self.e_cwd[:len(l_lwdTest)]:
      print "\nERROR: %s must be invoked under %s* !!!" %(basename(self.progName),l_lwdTest)
      print "  CWD: %s" %self.e_cwd
      sys.exit(-1)
    if self.opt_verbose:
      print "  CWD:   %s" %self.e_cwd
      print "  Local: %s" %self.e_lwd

    load_testList = []
    def_testList  = []

    # Load regular testLists
    #
    rootDir = '.'
    for dirName, subdirList, fileList in os.walk(rootDir):
      # modify subdirList to skip unwanted subdirectories
      # Note: os.walk flattens the structure
      #
      if 'CVS' in subdirList:
        subdirList.remove('CVS') # TODO: add other names to be skipped programatically

      for fname in fileList:
        if '.' in fname:
          fBase, fExt = os.path.splitext(fname)
          if fBase != 'default' and fExt == '.testList':
            load_testList.append(dirName + '/' + fname)

    # Load default testLists
    #
    startStr = None
    srchStr  = self.e_cwd[len(l_lwdTest):]
    slPos    = srchStr.find('/')
    if slPos < 0:
      startStr = self.e_cwd
    else:
      startStr = self.e_cwd[:len(l_lwdTest)+slPos]
    if self.opt_verbose:
      print "  - For default.testLists, start at %s" % startStr

    for dirName, subdirList, fileList in os.walk(startStr):
      # modify subdirList to skip unwanted subdirectories
      # Note: os.walk flattens the structure
      #
      if 'CVS' in subdirList:
        subdirList.remove('CVS') # TODO: add other names to be skipped programatically

      for fname in fileList:
        if fname == 'default.testList':
          def_testList.append(dirName + '/' + fname)

    if self.opt_verbose:
      if len(load_testList) == 0:
        print "\n  No *.testLists found!"
      else:
        print "\n  *.testLists to be loaded:"
        for fname in load_testList:
          print "  - %s" % fname
      if len(def_testList) == 0:
        print "  No default.testLists found!"
      else:
        print "  default.testLists to be loaded:"
        for fname in def_testList:
          print "  - %s" % fname

  def checkTestConfig(self):
    if self.opt_bin is None:
      self.opt_bin = 'runDelaySecs'  # TEMP for debugging -- TODO

  #-----------------------------------------------------------------------------
  def getTestList(self):
    """Returns a list of tests associated with the given label
       1- Find testLabel in test classes
       2- Find testLabel in test names
       3- Find testLabel as test file in local directory
    """

    l_testList = None

    #
    # TODO: get from testList config here
    #

    # No corresponding tests found, try local test
    #
    if l_testList == None:
      if self.testLabelInferred:
        return self.getLocalTest()
      else:
        print "ERROR: No tests to run!\n"
        self.printHelp(7)

    return l_testList

  def getLocalTest(self):
    l_testList = []

    # Both self.opt_testFile and testLabel should be defined
    #
    assert self.opt_testFile is not None
    assert self.testLabel    is not None

    tcArgDict = {
        'bin'        : self.opt_bin,
        'testName'   : self.testLabel,
        'testFile'   : self.opt_testFile,
        'numRuns'    : self.opt_numRuns,
        'runDir'     : self.opt_runDir,
        'forceSeed'  : self.opt_forceSeed,
        'randScript' : self.opt_randScript,
        'preRun'     : self.opt_preRun,
        'postRun'    : self.opt_postRun,
        'exArgs'     : self.opt_exArgs
      }

    aTest = self.testClass(**tcArgDict)

    l_testList.append(aTest)

    return l_testList

  #-----------------------------------------------------------------------------
  def launchTest(self,oneTest,idx):
    """Prepares and launches the test
       - Run directory created here in order to avoid name collision
       - Get the argument array from testClass
       - Creates the child process
       NOTE: Operates on one instance of a test, index is provided
    """

    def launchCheckTest(testObj,runIdx):
      """Checks the configuration before launching"""
      if testObj.bin is None:
        sys.stderr.write("ERROR: couldn't figure out binary file")
        sys.exit(8)

    def genRunDir(testObj,runIdx):
      """Creates the run directory"""
      runDir = testObj.runDir # TODO: expand to full path -- os.path.abspath()?
      i = 0
      while True:
        newDir = "%s/RUN.%s.%s.%d" %(runDir,testObj.bin,testObj.testName,i)
        if not os.path.isdir(newDir):
          return newDir
        i += 1

    def createLog(logName,cmdLst):
      """Creates the executable's log file and writes preliminary info"""
      try:
        logHand = open(logName,'w')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %logName)
        sys.exit(5)
      logHand.write('%s\n' % cmdLst)
      logHand.write('%s\n' % datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))
      logHand.write('--------------------------------------------------\n')
      logHand.close()

    def runLaunchDelegate(cmdLaunch,runDir):
      """Launches the actual process and returns the proc object
         NOTE:
           run.log    - executable's log file; set in self.runLogName
           launch.log - the launcher script's log file
                      - hardcoded file name cannot be changed
                      - contains metadata for pre/post scripts
      """
      launchLogName = runDir + '/launch.log'
      try:
        launchLogHand = open(launchLogName,'w')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %launchLogName)
        sys.exit(4)
      l_cmd = ['uLaunch.py'] + cmdLaunch + ["--logFile=" + self.runLogName]
      #
      # Call createLog here to print the final values for the command
      #
      createLog(runDir + "/" + self.runLogName,l_cmd)
      print "  +   %s" % l_cmd
      delgProc = subprocess.Popen(l_cmd, stdout=launchLogHand, stderr=launchLogHand, shell=False, preexec_fn=os.setsid, cwd=runDir)
      return delgProc
    #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    launchCheckTest(oneTest,idx)

    # 1- Create run directory here in order to avoid name collision
    #
    targetDir = genRunDir(oneTest,idx)
    print "  +   Create dir: %s" %targetDir
    os.makedirs(targetDir)

    # 2- Get command array from class
    #
    cmdArray = oneTest.getCmdArray()

    # 3- Launch process; redirect both STDOUT and STDERR to log file
    # Note:
    #   http://stackoverflow.com/questions/18344932/python-subprocess-call-stdout-to-file-stderr-to-file-display-stderr-on-scree
    # Long Term:
    #   Have the option to redirect STDERR to its own file
    #   Have the option to re-run the test
    subProc = runLaunchDelegate(cmdArray,targetDir)
    print "  +"

    return subProc

  #-----------------------------------------------------------------------------
  def run(self):
    """The main function of this class
       1- Search for any *.testList within current directory tree
          Search for default.testList until top-level test tree: ${LOCAL_WS_DIR}/test*
       2- Figure out testLabel:
         a) Standalone (not in *.testList)
         b) Test Name
         c) Test Class
       3- Launch tests
       4- Wait for child processes to complete, print every 5 secs
    """

    if self.opt_verbose:
      print "\n[launcher::run()]\n"

    # 1- Load test lists / config
    #
    self.loadTestConfig()
    self.checkTestConfig()

    # 2- Get test list from test label
    #
    self.testList = self.getTestList()

    # 3- Launch Tests
    #
    if self.opt_verbose:
      print "\n  Launching %d tests!" % len(self.testList)

    #if len(self.testList) == 1 and numRuns == 1
    #  #
    #  # This is for standalone interactive mode
    #  # TODO: interactive should be the default if there's only one test
    #  #
    #  os.system(self.testList[0].bin)
    #  return


    global g_proc
    g_proc = []
    for testObj in self.testList:
      if self.opt_verbose:
        print "  + launch: %s | %s | %s" %(testObj.bin,testObj.testName,testObj.testFile)
      # Expand each test into separate instances
      for idx in range(testObj.numRuns):
        g_proc.append( self.launchTest(testObj,idx) )

    # 4- Wait for child processes
    # TODO: design a cleaner mechanism
    #   - remove finished processes from array
    #   - if the file result.launchTest.temp exists, read it, save the result and delete
    #   - create a maximum time limit
    #
    l_doLoop = True
    while l_doLoop:
      numPend = 0
      numRun  = 0
      numDone = 0
      for oneProc in g_proc:
        if oneProc.poll() is None:
          numRun = numRun + 1
        else:
          numDone = numDone + 1
      if numPend == 0 and numRun == 0:
        l_doLoop = False

      print "\n\n\n"
      print "--------------------"
      print "- Polling Tests [%s]" %datetime.now().strftime('%Y-%m-%d %H:%M:%S')
      print "- Pending: %d, Running: %d, Done: %d" %(numPend,numRun,numDone)
      print "--------------------"
      time.sleep(4)


  #-----------------------------------------------------------------------------
  @atexit.register
  def launcherCleanup():
    """Kill any remaining child processes here
       - Invoked when program is terminating (via SIGKILL or finishing naturally)
    """
    global g_proc
    if g_proc is not None:
      pidKillList = []
      sys.stdout.flush()
      sys.stderr.write( "\n[launcherCleanup()]\n" )

      for oneProc in g_proc:
        if oneProc.poll() is None:
          sys.stderr.write( "- killing subprocess [pid=%d]\n" %oneProc.pid )
          pidKillList.append(oneProc.pid)
          oneProc.send_signal(signal.SIGINT)

      for onePid in pidKillList:
        os.killpg(onePid,signal.SIGTERM)
      sys.stderr.write( "\n\n" )
    #
    # Question: Should we save the launch log file handles and close them here?
    #


#-------------------------------------------------------------------------------

if __name__ == "__main__":
  launObj = launcher()
  launObj.setProgName( sys.argv[0]  )
  launObj.readArgs   ( sys.argv[1:] )
  launObj.run        ()

