#!/usr/bin/python
#-------------------------------------------------------------------------------
# Copyright (c) 2015 manxinator
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#-------------------------------------------------------------------------------
# launchTest
# Author:   manxinator
# Created:  Wed Oct  7 02:28:49 PDT 2015
# Language: Python 2.7.6
#-------------------------------------------------------------------------------

import os, sys, argparse, getopt
import signal, subprocess, time
import atexit
from datetime import datetime
from os.path import basename

g_proc      = None
g_tcPars    = None
g_launchScr = 'uLaunch.py'

#-------------------------------------------------------------------------------
class launcher:
  """Launcher class is a top level regressable script"""

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class testClass:
    def __init__(self,**kwargs):
      self.bin        = None
      self.testName   = None
      self.testFile   = None
      self.numRuns    = None
      self.runDir     = None
      self.forceSeed  = None
      self.randScript = None
      self.preRun     = None
      self.postRun    = None
      self.exArgs     = None
      if kwargs is not None:
        if 'bin'        in kwargs: self.bin        = kwargs['bin'       ]
        if 'testName'   in kwargs: self.testName   = kwargs['testName'  ]
        if 'testFile'   in kwargs: self.testFile   = kwargs['testFile'  ]
        if 'numRuns'    in kwargs: self.numRuns    = kwargs['numRuns'   ]
        if 'runDir'     in kwargs: self.runDir     = kwargs['runDir'    ]
        if 'forceSeed'  in kwargs: self.forceSeed  = kwargs['forceSeed' ]
        if 'randScript' in kwargs: self.randScript = kwargs['randScript']
        if 'preRun'     in kwargs: self.preRun     = kwargs['preRun'    ]
        if 'postRun'    in kwargs: self.postRun    = kwargs['postRun'   ]
        if 'exArgs'     in kwargs: self.exArgs     = kwargs['exArgs'    ]

    def getCmdArray(self):
      whichBin = subprocess.Popen(['which',self.bin],shell=False,stdout=subprocess.PIPE,preexec_fn=os.setsid)
      binPath  = whichBin.stdout.read().strip()
      retArray = [binPath]
      if self.randScript is not None: retArray = retArray + ["--randScript=" + self.randScript]
      if self.forceSeed  is not None: retArray = retArray + ["--forceSeed=%d" % self.forceSeed]
      if self.preRun     is not None: retArray = retArray + ["--preRun=%s"    % self.preRun]
      if self.postRun    is not None: retArray = retArray + ["--postRun=%s"   % self.postRun]
      if self.testFile   is not None: retArray = retArray + ["--testFile="  + self.testFile]
      if self.exArgs     is not None: retArray = retArray + ["--extraArgs=" + self.exArgs]
      return retArray

    def parseStr(self,args,prefix=None):
      global g_tcPars
      l_args = g_tcPars.parse_args(args)

      self.numRuns    = l_args.numRuns
      self.forceSeed  = l_args.forceSeed
      if l_args.bin        is not None: self.bin        = l_args.bin[0]
      if l_args.testName   is not None: self.testName   = l_args.testName[0]
      if l_args.testFile   is not None: self.testFile   = l_args.testFile[0]
      if l_args.runDir     is not None: self.runDir     = l_args.runDir[0]
      if l_args.randScript is not None: self.randScript = l_args.randScript[0]
      if l_args.preRun     is not None: self.preRun     = l_args.preRun[0]
      if l_args.postRun    is not None: self.postRun    = l_args.postRun[0]
      if l_args.extraArgs  is not None: self.exArgs     = l_args.extraArgs[0]

      if prefix is not None:
        if self.runDir is None:
          self.runDir = prefix
        else:
          self.runDir = prefix + '/' + self.runDir
      else:
        if self.runDir is None: self.runDir = '.'

      if self.numRuns  is None: self.numRuns  = 1
      if self.testName is None:
        if self.testFile is not None:
          dotPos = self.testFile.find('.')
          self.testName = self.testFile[:dotPos]

      doPrint = True
      if doPrint:
        self.printMembers()
        print ''

    def printMembers(self,outFh=sys.stdout):
      methodList = [method for method in dir(self) if (not callable(getattr(self,method))) and (method[0] != '_')]
      strLen     = len(max(methodList,key=len))
      fmtStr     = '{:' + str(strLen) + '}'
      outFh.write( "********** [testClass::printMembers]\n" )
      for oneStr in methodList:
        outFh.write( "* %s = %s\n" %(fmtStr.format(oneStr),str(self.__dict__[oneStr])) )
      outFh.write( "******************************\n" )

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class tlClass:
    """Class that abstracts Test Lists"""
    def __init__(self,**kwargs):
      self.tlName  = None      # instance name of TL file
      self.tlList  = []
      self.dirPref = None      # directory prefix

      self.dirPath  = None
      self.fileName = None
      self.verbose  = None
      self.parent   = None
      if kwargs is not None:
        if 'dirPath'  in kwargs: self.dirPath  = kwargs['dirPath']
        if 'fileName' in kwargs: self.fileName = kwargs['fileName']
        if 'verb'     in kwargs: self.verbose  = kwargs['verb']
        if 'origin'   in kwargs: self.parent   = kwargs['origin']

      if (self.dirPath is not None) and (self.fileName is not None):
        self.loadFile()
      elif self.fileName is not None:
        self.setTlName()

    def setTlName(self):
      dotPos = self.fileName.rfind('.')
      self.tlName = self.fileName[:dotPos]

    def loadFile(self):
      # Fix fileName and dirPath
      self.fileName = self.fileName.lstrip('./')
      self.dirPath  = self.dirPath.rstrip('/')
      slPos         = self.fileName.rfind('/')
      if slPos >= 0:
        self.dirPath  = self.dirPath + '/' + self.fileName[:slPos]
        self.fileName = self.fileName[slPos+1:]
      self.setTlName()

      self.dirPref = self.dirPath[len(self.parent.e_cwd)+1:]
      print "  + Loading: %s in %s [%s]" % (self.fileName,self.dirPath,self.dirPref)
      tlFN = self.dirPath + '/' + self.fileName
      try:
        tlFH = open(tlFN,'r')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %tlFN)
        sys.exit(108)
      else:
        with tlFH:
          for oneLine in tlFH:
            # TODO: add support for `group and other advanced features
            remPos  = oneLine.find('#')
            oneLine = oneLine[:remPos].strip() if remPos >= 0 else oneLine.strip()
            if len(oneLine) < 1:
              continue
            tmpSpl    = oneLine.split(' ')
            parseArgs = [myArg for myArg in tmpSpl if myArg != '']

            oneTest = self.parent.testClass()
            oneTest.parseStr(parseArgs,prefix=self.dirPref)
            self.tlList.append( oneTest )
        #parent.e_cwd


  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
  class tlDefault:
    """Class that abstracts Default Test Lists"""
    def __init__(self,**kwargs):
      self.tlList = []

      self.dirPath  = None
      self.fileName = None
      self.verbose  = None
      if kwargs is not None:
        if 'dirPath'  in kwargs: self.dirPath  = kwargs['dirPath']
        if 'fileName' in kwargs: self.fileName = kwargs['fileName']
        if 'verb'     in kwargs: self.verbose  = kwargs['verb']

      if (self.dirPath is not None) and (self.fileName is not None):
        self.loadFile()

    def loadFile(self):
      # Fix fileName and dirPath
      print "  + Loading: %s" % self.fileName

  #= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

  def __init__(self):
    """Initialization for launcher class"""
    self.progName = None

    self.opt_verbose     = True
    self.opt_bin         = None
    self.opt_testFile    = None       # currently, only used in self.inferTestLabel()
    self.opt_numRuns     = 1
    self.opt_runDir      = '.'
    self.opt_forceSeed   = None
    self.opt_randScript  = None
    self.opt_preRun      = None
    self.opt_postRun     = None
    self.opt_testSuff    = ".aok"
    self.opt_exArgs      = None
    self.testLabel       = None

    self.e_cwd = os.getcwd().rstrip('/')      # os.environ.get('PWD')
    self.e_lwd = os.environ['LOCAL_WS_DIR'].rstrip('/')

    self.testLabelInferred = False
    self.runLogName        = "run.log"   # Perhaps make this programmable

    self.cfg_testList     = []    # List of *.tl files
    self.cfg_defList      = []

    self.collectId_name   = []    # Test ID collection for Test Names
    self.collectId_group  = []    # Test ID collection for Groups

  def setProgName(self,a_progName):
    """ Sets program name for printing -- may be cleaned up: basename, etc. """
    self.progName = a_progName

  def printHelp(self,exitCode):
    """ Prints the help instructions and exits. """
    # TODO: categorize options to: standalone, multi, both
    #
    print("Usage: %s [OPTIONS] TEST_LABEL" % basename(self.progName))
    print("  -b <STR>, --bin=<STR>         Executable binary")
    print("  -t <STR>, --testFile=<STR>    Specify test file")
    print("                                - only used when TEST_LABEL not defined")
    print("                                - standalone test only")
    print("  -n <NUM>, --numRuns=<NUM>     Number of runs             [STANDALONE]")
    print("  -d <STR>, --runDir=<STR>      Directory of the test case [STANDALONE]")
    print("  -F <NUM>, --forceSeed=<NUM>   Run test with given random seed")
    print("  -r <STR>, --randScript=<STR>  Specify random seed generator script")
    print("  -P <STR>, --preRun=<STR>      Comma-separated list of pre-run scripts")
    print("  -p <STR>, --postRun=<STR>     Comma-separated list of post-run scripts")
    print("  -z <STR>, --testSuffix=<STR>  Specify test suffix; defaults to '.aok'")
    print("  -x <STR>, --extraArgs=<STR>   Additional arguments")
    print("--------------------------------------------------")
    print("  -h, --help                    Help")
    print("  -v, --verbose                 Verbose")
    sys.exit(exitCode)

  def readArgs(self,a_argv):
    longArgs = [
        "bin=",
        "testFile=",
        "numRuns=",
        "runDir=",
        "forceSeed=",
        "randScript=",
        "preRun=",
        "postRun=",
        "testSuffix=",
        "extraArgs=",
      ]
    try:
      opts, remainder = getopt.getopt(a_argv,"hvb:t:n:d:F:r:P:p:z:x:",longArgs)
    except getopt.GetoptError:
      self.printHelp(2)

    for opt, arg in opts:
      if   opt in ("-h","--help"):       self.printHelp(0)
      elif opt in ("-v","--verbose"):    self.opt_verbose    = True
      elif opt in ("-b","--bin"):        self.opt_bin        = arg
      elif opt in ("-t","--testFile"):   self.opt_testFile   = arg
      elif opt in ("-n","--numRuns"):    self.opt_numRuns    = int(arg)
      elif opt in ("-d","--runDir"):     self.opt_runDir     = arg
      elif opt in ("-F","--forceSeed"):  self.opt_forceSeed  = int(arg)
      elif opt in ("-r","--randScript"): self.opt_randScript = arg
      elif opt in ("-P","--preRun"):     self.opt_preRun     = arg
      elif opt in ("-p","--postRun"):    self.opt_postRun    = arg
      elif opt in ("-z","--testSuffix"): self.opt_testSuff   = arg
      elif opt in ("-x","--extraArgs"):  self.opt_exArgs     = arg
      else:
        print("Unknown option %s" % opt)

    if not self.opt_testSuff.strip():
      print "\nERROR: empty test suffix not supported!!!"
      sys.exit(-9)
    else:
      if self.opt_testSuff[0] != '.':
        self.opt_testSuff = '.' + self.opt_testSuff

    # Determine the test label here
    remLen = len(remainder)
    if remLen == 0: self.testLabel = self.inferTestLabel()  # TODO: fix this function to use opt_runDir
    else:           self.testLabel = self.preCheckLabel(remainder)

    if True:    # self.opt_verbose
      if self.opt_bin        is not None: print("- opt_bin       : %s" % self.opt_bin       )
      if self.opt_testFile   is not None: print("- opt_testFile  : %s" % self.opt_testFile  )
      if self.opt_numRuns    is not None: print("- opt_numRuns   : %d" % self.opt_numRuns   )
      if self.opt_runDir     is not None: print("- opt_runDir    : %s" % self.opt_runDir    )
      if self.opt_forceSeed  is not None: print("- opt_forceSeed : %d" % self.opt_forceSeed )
      if self.opt_randScript is not None: print("- opt_randScript: %s" % self.opt_randScript)
      if self.opt_preRun     is not None: print("- opt_preRun    : %s" % self.opt_preRun    )
      if self.opt_postRun    is not None: print("- opt_postRun   : %s" % self.opt_postRun   )
      if self.opt_testSuff   is not None: print("- opt_testSuff  : %s" % self.opt_testSuff  )
      if self.opt_exArgs     is not None: print("- opt_exArgs    : %s" % self.opt_exArgs    )
      if self.testLabel      is not None: print("- testLabel     : %s" % self.testLabel     )

  def inferTestLabel(self):
    """Try to figure out test label
       1- if testFile specified, use it
       2- find <CWD>.<TEST_SUFF> in local directory ---> TEST_LABEL = basename(pwd)
       3- find <TEST_LABEL>.<TEST_SUFF> in local directory
       NOTE: self.opt_testFile ends up being defined either way
    """
    self.testLabelInferred = True
    if self.opt_testFile is not None:
      fileStr = self.opt_testFile[:len(self.opt_testFile)-len(self.opt_testSuff)]
      return fileStr
    bpwd = basename(self.e_cwd)
    if os.path.isfile(bpwd + self.opt_testSuff):
      self.opt_testFile = bpwd + self.opt_testSuff
      return bpwd
    fileList = [oneF for oneF in os.listdir('.') if os.path.isfile(oneF) and oneF.endswith(self.opt_testSuff)]
    if len(fileList) == 1:
      # Strip out the suffix
      self.opt_testFile = fileList[0]
      fileStr = self.opt_testFile[:len(self.opt_testFile)-len(self.opt_testSuff)]
      return fileStr
    print "ERROR: couldn't figure out test case"
    sys.exit(-6)

  def preCheckLabel(self,argLst):
    """Preliminary checking of testLabel argument"""
    l_label = argLst[0]
    if len(argLst) > 1:
      print "WARNING: multiple labels not supported at this time!"
    if l_label == '.':
      l_label = self.inferTestLabel()
    # For standalone labels
    # - Perhaps rename self.testLabelInferred variable
    if os.path.isfile(l_label + self.opt_testSuff):
      self.testLabelInferred = True
      self.opt_testFile      = l_label + self.opt_testSuff
    return l_label

  #-----------------------------------------------------------------------------
  def loadTestConfig(self):
    """Loads test list files
    """
    if self.opt_verbose:
      print("\n[launcher::loadTestConfig()]\n")

    # Check script's CWD
    l_lwdTest = self.e_lwd + '/test'
    if l_lwdTest != self.e_cwd[:len(l_lwdTest)]:
      print "\nERROR: %s must be invoked under %s* !!!" %(basename(self.progName),l_lwdTest)
      print "  CWD: %s" %self.e_cwd
      sys.exit(-1)
    if self.opt_verbose:
      print "  CWD:   %s" %self.e_cwd
      print "  Local: %s" %self.e_lwd

    load_testList = []
    def_testList  = []

    # Find regular TL files in the expected locations
    #
    rootDir = '.'
    for dirName, subdirList, fileList in os.walk(rootDir):
      # modify subdirList to skip unwanted subdirectories
      # Note: os.walk flattens the structure
      #
      if 'CVS' in subdirList:
        subdirList.remove('CVS') # TODO: add other names to be skipped programatically

      for fname in fileList:
        if '.' in fname:
          fBase, fExt = os.path.splitext(fname)
          if fBase != 'default' and fExt == '.tl':
            load_testList.append(dirName + '/' + fname)

    # Find the default TL file -- only one
    #
    endStr  = None
    srchStr = self.e_cwd[len(l_lwdTest):]
    slPos   = srchStr.find('/')

    if slPos < 0:
      endStr = self.e_cwd
    else:
      endStr = self.e_cwd[:len(l_lwdTest)+slPos]
    if self.opt_verbose:
      print "  - For default.tl, end at %s" % endStr

    checkDir  = self.e_cwd
    fileFound = False
    while True:
      filePath  = checkDir + '/default.tl'
      fileFound = os.path.isfile(filePath)
      if fileFound:
        def_testList.append(filePath )
        print "  * Found: %s" % filePath
        break
      slPos = checkDir.rfind('/')
      checkDir = checkDir[:slPos]
      # A lexicographic comparison would be better than length comparison
      # If equal, there should be one more iteration
      if len(checkDir) < len(endStr):
        break
    assert (len(def_testList)) < 2  # Only 1 default testList supported for now

    # Debug printing
    #
    if self.opt_verbose:
      if len(load_testList) == 0:
        print "\n  No *.tl found!"
      else:
        print "\n  *.tl to be loaded:"
        for fname in load_testList:
          print "  - %s" % fname
      if len(def_testList) == 0:
        print "  No default.tl found!"
      else:
        print "  default.tl to be loaded:"
        for fname in def_testList:
          print "  - %s" % fname
    print ''

    # Find regular TL files in the expected locations
    #
    for fname in load_testList:
      self.cfg_testList.append( self.tlClass(fileName=fname,dirPath=self.e_cwd,verb=self.opt_verbose,origin=self) )
    for fname in def_testList:
      self.cfg_defList.append( self.tlDefault(fileName=fname,dirPath=self.e_cwd,verb=self.opt_verbose) )

  def analyzeTestConfig(self):
    """Perform the following
       - Propagate settings
       - Load all ID's {testName, groups} and verify uniqueness; {*.tl name} doesn't need to be unique (last to be searched -- if none found)
         - Also, perform test case sanity checking
       NOTE: Other checking is deferred to when retrieving test list
    """

    # 1- propagage default settings to each Test List
    #

    # 2- Load all ID's
    #   - Include test case sanity check
    #
    for oneTl in self.cfg_testList:
      for oneTest in oneTl.tlList:
        # Basic checks -- TODO: convert these to proper error messages (use a function)
        assert oneTest.bin      is not None
        assert oneTest.testName is not None
        assert oneTest.testFile is not None
        assert oneTest.numRuns  is not None
        assert oneTest.runDir   is not None
        if oneTest.testName in self.collectId_name:
          print "ERROR: Duplicate Test Name '%s' found in %s!" %(oneTest.testName,oneTl.fileName)
          sys.exit(106)
        self.collectId_name.append(oneTest.testName)

      # TODO: iterate for Test Groups also -- self.collectId_group
      # for oneTest in oneTl.tlList:


    if self.opt_bin is None:
      self.opt_bin = 'runDelaySecs'  # TEMP for debugging -- TODO

  #-----------------------------------------------------------------------------
  def searchTestList(self,labelId):
    """Search for the given label
       1- Test Names
       2- Groups
       3- TL Files
       4- Pre-run sanity checking
    """
    retList = None

    if labelId in self.collectId_name:
      # Test Name
      for oneTl in self.cfg_testList:
        for oneTest in oneTl.tlList:
          if labelId == oneTest.testName:
            retList = [oneTest]
            break

    if retList is None:
      if labelId in self.collectId_group:
        # Group
        pass

    if retList is None:
      for oneTl in self.cfg_testList:
        if labelId == oneTl.tlName:
          # TL File
          retList = oneTl.tlList
          break

    if retList is not None:
      # Pre-run sanity checking
      # - bin exists
      # - remove tests with numRuns < 1
      # - all scripts exists
      # - test file exists
      pass

    if len(retList) == 0:
      return None
    return retList

  #-----------------------------------------------------------------------------
  def getTestList(self):
    """Returns a list of tests associated with the given label
       1- Find testLabel in test classes
       2- Find testLabel in test names
       3- Find testLabel as test file in local directory
    """

    l_testList = None

    #
    # get from testList config here -- perform a search
    #
    if len(self.cfg_testList) > 0:
      l_testList = self.searchTestList(self.testLabel)

    # No corresponding tests found, try local test
    #
    if l_testList == None:
      if self.testLabelInferred:
        return self.getLocalTest()
      else:
        print '\nERROR: No tests to run!'   # TODO: -- print meaningful errors
        print '--------------------------------------------------'
        self.printHelp(7)

    return l_testList

  def getLocalTest(self):
    l_testList = []

    # Both self.opt_testFile and testLabel should be defined
    #
    assert self.opt_testFile is not None
    assert self.testLabel    is not None

    tcArgDict = {
        'bin'        : self.opt_bin,
        'testName'   : self.testLabel,
        'testFile'   : self.opt_testFile,
        'numRuns'    : self.opt_numRuns,
        'runDir'     : self.opt_runDir,
        'forceSeed'  : self.opt_forceSeed,
        'randScript' : self.opt_randScript,
        'preRun'     : self.opt_preRun,
        'postRun'    : self.opt_postRun,
        'exArgs'     : self.opt_exArgs
      }

    aTest = self.testClass(**tcArgDict)
    aTest.printMembers()

    l_testList.append(aTest)

    return l_testList

  #-----------------------------------------------------------------------------
  def launchTest(self,oneTest,idx):
    """Prepares and launches the test
       - Run directory created here in order to avoid name collision
       - Get the argument array from testClass
       - Creates the child process
       NOTE: Operates on one instance of a test, index is provided
    """

    def launchCheckTest(testObj,runIdx):
      """Checks the configuration before launching"""
      if testObj.bin is None:
        sys.stderr.write("ERROR: couldn't figure out binary file")
        sys.exit(103)

    def genRunDir(testObj,runIdx):
      """Creates the run directory"""
      runDir = testObj.runDir # TODO: expand to full path -- os.path.abspath()?
      i = 0
      while True:
        newDir = "%s/RUN.%s.%s.%d" %(runDir,testObj.bin,testObj.testName,i)
        if not os.path.isdir(newDir):
          break
        i += 1
      print "  +   Create dir: %s" %newDir
      os.makedirs(newDir)

      walkDir = self.e_cwd + '/' + runDir
      walkOff = len(walkDir)
      print "  +   walkDir: %s" %walkDir
      for dirName, subdirList, fileList in os.walk(walkDir):
        # modify subdirList to skip unwanted subdirectories
        # Note: os.walk flattens the structure
        #
        if len(dirName) > walkOff:
          continue
        else:
          l_dirName = ''

        if 'CVS' in subdirList:
          subdirList.remove('CVS') # TODO: add other names to be skipped programatically
        l_RUNDir = []
        for aDir in subdirList:
          if aDir.find('RUN.') == 0:
            l_RUNDir.append(aDir)
        for aDir in l_RUNDir:
          subdirList.remove(aDir)

        # Create symbolic links
        for fname in fileList:
          os.symlink( '../' + fname, newDir + '/' + fname)      #os.symlink( walkDir + '/' + fname, newDir + '/' + fname)
        for aDir in subdirList:
          os.symlink( '../' + aDir, newDir + '/' + aDir)        #os.symlink( walkDir + '/' + aDir, newDir + '/' + aDir)

      return newDir

    def createLog(logName,cmdLst,refTC):
      """Creates the executable's log file and writes preliminary info"""
      try:
        logHand = open(logName,'w')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %logName)
        sys.exit(104)
      logHand.write('%s\n' % cmdLst)
      logHand.write('%s\n' % datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))
      logHand.write('--------------------------------------------------\n')
      refTC.printMembers(logHand)
      logHand.write('--------------------------------------------------\n\n')
      logHand.close()

    def runLaunchDelegate(cmdLaunch,runDir,refTestClass):
      """Launches the actual process and returns the proc object
         NOTE:
           run.log    - executable's log file; set in self.runLogName
           launch.log - the launcher script's log file
                      - hardcoded file name cannot be changed
                      - contains metadata for pre/post scripts
      """
      launchLogName = runDir + '/launch.log'
      try:
        launchLogHand = open(launchLogName,'w')
      except IOError:
        sys.stderr.write("Failed to open %s for writing" %launchLogName)
        sys.exit(105)
      global g_launchScr
      l_cmd = [g_launchScr] + cmdLaunch + ["--logFile=" + self.runLogName]
      #
      # Call createLog here to print the final values for the command
      #
      createLog(runDir + "/" + self.runLogName,l_cmd,refTestClass)
      print "  +   %s" % l_cmd
      delgProc = subprocess.Popen(l_cmd, stdout=launchLogHand, stderr=launchLogHand, shell=False, preexec_fn=os.setsid, cwd=runDir)
      return delgProc
    #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    launchCheckTest(oneTest,idx)

    # 1- Create run directory here in order to avoid name collision
    #
    targetDir = genRunDir(oneTest,idx)

    # 2- Get command array from class
    #
    cmdArray = oneTest.getCmdArray()

    # 3- Launch process; redirect both STDOUT and STDERR to log file
    # Note:
    #   http://stackoverflow.com/questions/18344932/python-subprocess-call-stdout-to-file-stderr-to-file-display-stderr-on-scree
    # Long Term:
    #   Have the option to redirect STDERR to its own file
    #   Have the option to re-run the test
    subProc = runLaunchDelegate(cmdArray,targetDir,oneTest)
    print "  +"

    return subProc

  #-----------------------------------------------------------------------------
  def run(self):
    """The main function of this class
       1- Search for any *.tl within current directory tree
          Search for default.tl until top-level test tree: ${LOCAL_WS_DIR}/test*
       2- Figure out testLabel:
         a) Standalone (not in *.tl)
         b) Test Name
         c) Test Class
       3- Launch tests
       4- Wait for child processes to complete, print every 5 secs
    """

    if self.opt_verbose:
      print "\n[launcher::run()]\n"

    # 1- Load test lists / config
    #
    self.loadTestConfig()
    self.analyzeTestConfig()

    # 2- Get test list from test label
    #
    self.testList = self.getTestList()

    # 3- Launch Tests
    #
    if self.opt_verbose:
      print "\n  Launching %d tests!" % len(self.testList)

    #if len(self.testList) == 1 and numRuns == 1
    #  #
    #  # This is for standalone interactive mode
    #  # TODO: interactive should be the default if there's only one test
    #  #
    #  os.system(self.testList[0].bin)
    #  return


    global g_proc
    g_proc = []
    for testObj in self.testList:
      if self.opt_verbose:
        print "  + launch: %s | %s | %s" %(testObj.bin,testObj.testName,testObj.testFile)
      # Expand each test into separate instances
      for idx in range(testObj.numRuns):
        g_proc.append( self.launchTest(testObj,idx) )

    # 4- Wait for child processes
    # TODO: design a cleaner mechanism
    #   - remove finished processes from array
    #   - if the file result.launchTest.temp exists, read it, save the result and delete
    #   - create a maximum time limit
    #
    l_doLoop = True
    while l_doLoop:
      numPend = 0
      numRun  = 0
      numDone = 0
      for oneProc in g_proc:
        if oneProc.poll() is None:
          numRun = numRun + 1
        else:
          numDone = numDone + 1
      if numPend == 0 and numRun == 0:
        l_doLoop = False

      print "\n\n\n"
      print "--------------------"
      print "- Polling Tests [%s]" %datetime.now().strftime('%Y-%m-%d %H:%M:%S')
      print "- Pending: %d, Running: %d, Done: %d" %(numPend,numRun,numDone)
      print "--------------------"
      time.sleep(4)


  #-----------------------------------------------------------------------------
  @atexit.register
  def launcherCleanup():
    """Kill any remaining child processes here
       - Invoked when program is terminating (via SIGKILL or finishing naturally)
    """
    global g_proc
    if g_proc is not None:
      pidKillList = []
      sys.stdout.flush()
      sys.stderr.write( "\n[launcherCleanup()]\n" )

      for oneProc in g_proc:
        if oneProc.poll() is None:
          sys.stderr.write( "- killing subprocess [pid=%d]\n" %oneProc.pid )
          pidKillList.append(oneProc.pid)
          oneProc.send_signal(signal.SIGINT)

      for onePid in pidKillList:
        os.killpg(onePid,signal.SIGTERM)
      sys.stderr.write( "\n\n" )
    #
    # Question: Should we save the launch log file handles and close them here?
    #


#-------------------------------------------------------------------------------

def initGlob():
  global g_tcPars
  g_tcPars = argparse.ArgumentParser()
  g_tcPars.add_argument('-b', '--bin',        nargs=1,   dest='bin',                               help='Executable Program')
  g_tcPars.add_argument('-N', '--testName',   nargs=1,   dest='testName',                          help='Test name')
  g_tcPars.add_argument('-f', '--testFile',   nargs=1,   dest='testFile',                          help='Test file')
  g_tcPars.add_argument('-n', '--numRuns',    nargs=1,   dest='numRuns',    type=int, default=1,   help='Number of runs')
  g_tcPars.add_argument('-d', '--runDir',     nargs=1,   dest='runDir',               default='.', help='Directory which will contain the run directories')
  g_tcPars.add_argument('-F', '--forceSeed',  nargs=1,   dest='forceSeed',  type=int,              help='Forcibly override random seed')
  g_tcPars.add_argument('-r', '--randScript', nargs=1,   dest='randScript',                        help='Specify random seed generator script')
  g_tcPars.add_argument('-P', '--preRun',     nargs=1,   dest='preRun',                            help='Comma-separated list of pre-run scripts')
  g_tcPars.add_argument('-p', '--postRun',    nargs=1,   dest='postRun',                           help='Comma-separated list of post-run scripts')
  g_tcPars.add_argument('-x', '--extraArgs',  nargs='+', dest='extraArgs',                         help='Arguments for the executable')

#-------------------------------------------------------------------------------

if __name__ == "__main__":
  initGlob()
  launObj = launcher()
  launObj.setProgName( sys.argv[0]  )
  launObj.readArgs   ( sys.argv[1:] )
  launObj.run        ()

